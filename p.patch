diff --git a/hal/Android.mk b/hal/Android.mk
index af9da86..8e59df6 100644
--- a/hal/Android.mk
+++ b/hal/Android.mk
@@ -114,7 +114,6 @@ endif
 
 ifeq ($(strip $(AUDIO_FEATURE_ENABLED_DTS_EAGLE)),true)
     LOCAL_CFLAGS += -DDTS_EAGLE
-    LOCAL_ADDITIONAL_DEPENDENCIES += $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr
     LOCAL_SRC_FILES += audio_extn/dts_eagle.c
 endif
 
diff --git a/hal/audio_extn/audio_extn.c b/hal/audio_extn/audio_extn.c
index 01282e0..500dc41 100644
--- a/hal/audio_extn/audio_extn.c
+++ b/hal/audio_extn/audio_extn.c
@@ -141,8 +141,7 @@ void audio_extn_hpx_set_parameters(struct audio_device *adev,
     ret = str_parms_get_str(parms, AUDIO_PARAMETER_HPX, value,
                             sizeof(value));
     if (ret >= 0) {
-        if ((!strncmp("true", value, sizeof("true")) || atoi(value)) ||
-            (!strncmp("ON", value, sizeof("ON"))))
+        if (!strncmp("ON", value, sizeof("ON")))
             hpx_state = true;
 
         if (hpx_state == aextnmod.hpx_enabled)
diff --git a/hal/audio_extn/audio_extn.h b/hal/audio_extn/audio_extn.h
index cbbe4d6..005e063 100644
--- a/hal/audio_extn/audio_extn.h
+++ b/hal/audio_extn/audio_extn.h
@@ -230,24 +230,23 @@ void audio_extn_compr_cap_deinit();
 #ifndef DTS_EAGLE
 #define audio_extn_dts_eagle_set_parameters(adev, parms)     (0)
 #define audio_extn_dts_eagle_get_parameters(adev, query, reply) (0)
-#define audio_extn_dts_eagle_fade(adev, fadeIn) (0)
-#define audio_extn_dts_create_state_notifier_node(streamOut) (0)
-#define audio_extn_dts_notify_playback_state(streamOut, hasVideo, sampleRate, \
-                                             channels, isPlaying, isHpxPreprocessed) (0)
-#define audio_extn_dts_remove_state_notifier_node(streamOut) (0)
+#define audio_extn_dts_eagle_fade(adev, fade_in) (0)
+#define audio_extn_dts_create_state_notifier_node(stream_out) (0)
+#define audio_extn_dts_notify_playback_state(stream_out, has_video, sample_rate, \
+                                    channels, is_playing, is_hpx_preprocessed) (0)
+#define audio_extn_dts_remove_state_notifier_node(stream_out) (0)
 #define audio_extn_dts_set_hpx_state(state) (0)
 #else
 void audio_extn_dts_eagle_set_parameters(struct audio_device *adev,
                                          struct str_parms *parms);
 int audio_extn_dts_eagle_get_parameters(const struct audio_device *adev,
                   struct str_parms *query, struct str_parms *reply);
-int audio_extn_dts_eagle_fade(const struct audio_device *adev, bool fadeIn);
-void audio_extn_dts_create_state_notifier_node(int streamOut);
-void audio_extn_dts_notify_playback_state(int streamOut, int hasVideo, int sampleRate,
-                                          int channels, int isPlaying, int isHpxPreprocessed);
-void audio_extn_dts_remove_state_notifier_node(int streamOut);
+int audio_extn_dts_eagle_fade(const struct audio_device *adev, bool fade_in);
+void audio_extn_dts_create_state_notifier_node(int stream_out);
+void audio_extn_dts_notify_playback_state(int stream_out, int has_video, int sample_rate,
+                                  int channels, int is_playing, int is_hpx_preprocessed);
+void audio_extn_dts_remove_state_notifier_node(int stream_out);
 void audio_extn_dts_set_hpx_state(bool state);
-void audio_extn_dts_init_bypass(struct mixer *mixer, int pcm_device_id);
 #endif
 
 #if defined(DS1_DOLBY_DDP_ENABLED) || defined(DS1_DOLBY_DAP_ENABLED)
diff --git a/hal/audio_extn/dts_eagle.c b/hal/audio_extn/dts_eagle.c
index b54dfd0..4c03c4c 100644
--- a/hal/audio_extn/dts_eagle.c
+++ b/hal/audio_extn/dts_eagle.c
@@ -88,25 +88,26 @@ static int do_DTS_Eagle_params(const struct audio_device *adev, struct dts_eagle
 
     list_for_each(node, &adev->usecase_list) {
         usecase = node_to_item(node, struct audio_usecase, list);
-        if (usecase->type == PCM_PLAYBACK) {
+        /* set/get eagle params for offload usecases only */
+        if ((usecase->type == PCM_PLAYBACK) && is_offload_usecase(usecase->id)) {
             int tret = do_DTS_Eagle_params_stream(usecase->stream.out, t, get);
-                if (tret < 0)
-                    ret = tret;
+            if (tret < 0)
+                ret = tret;
         }
     }
     return ret;
 }
 
-int audio_extn_dts_eagle_fade(const struct audio_device *adev, bool fadeIn) {
+int audio_extn_dts_eagle_fade(const struct audio_device *adev, bool fade_in) {
     char prop[PROPERTY_VALUE_MAX];
 
-    ALOGI("DTS_EAGLE_HAL (%s): enter with fade %s requested", __func__, fadeIn ? "in" : "out");
+    ALOGI("DTS_EAGLE_HAL (%s): enter with fade %s requested", __func__, fade_in ? "in" : "out");
 
     property_get("use.dts_eagle", prop, "0");
     if (strncmp("true", prop, sizeof("true")))
         return 0;
 
-    if(fadeIn)
+    if(fade_in)
         return do_DTS_Eagle_params(adev, fade_in_data, false);
     return do_DTS_Eagle_params(adev, fade_out_data, false);
 }
@@ -244,6 +245,7 @@ int audio_extn_dts_eagle_get_parameters(const struct audio_device *adev,
                   struct str_parms *query, struct str_parms *reply) {
     int ret, val;
     char value[32] = { 0 }, prop[PROPERTY_VALUE_MAX];
+    char params[512];
 
     ALOGI("DTS_EAGLE_HAL (%s): enter", __func__);
 
@@ -251,10 +253,10 @@ int audio_extn_dts_eagle_get_parameters(const struct audio_device *adev,
     if (strncmp("true", prop, sizeof("true")))
         return 0;
 
-    memset(value, 0, sizeof(value));
     ret = str_parms_get_str(query, AUDIO_PARAMETER_KEY_DTS_EAGLE, value, sizeof(value));
     if (ret >= 0) {
-        int *data = NULL, id, size, offset, count = 1, dev, idx = 0, dts_found = 0, i;
+        int *data = NULL, id = 0, size = 0, offset = 0,
+            count = 1, dev = 0, idx = 0, dts_found = 0, i = 0;
         const size_t chars_4_int = 16;
         ret = str_parms_get_str(query, "count", value, sizeof(value));
         if (ret >= 0) {
@@ -287,7 +289,7 @@ int audio_extn_dts_eagle_get_parameters(const struct audio_device *adev,
 
         if (dts_found) {
             ALOGI("DTS_EAGLE_HAL (%s): param (get) detected: %s", __func__, str_parms_to_str(query));
-            struct dts_eagle_param_desc_alsa *t = (struct dts_eagle_param_desc_alsa*)malloc(sizeof(struct dts_eagle_param_desc_alsa) + size);
+            struct dts_eagle_param_desc_alsa *t = (struct dts_eagle_param_desc_alsa *)params;
             if(t) {
                 char buf[chars_4_int*count];
                 t->alsa_effect_ID = DTS_EAGLE_MODULE;
@@ -295,25 +297,38 @@ int audio_extn_dts_eagle_get_parameters(const struct audio_device *adev,
                 t->d.size = size;
                 t->d.offset = offset;
                 t->d.device = dev | DTS_EAGLE_FLAG_ALSA_GET;
-                ALOGD("DTS_EAGLE_HAL (%s): id (get): 0x%X, size: %d, offset: %d, device: %d", __func__,
+                ALOGV("DTS_EAGLE_HAL (%s): id (get): 0x%X, size: %d, offset: %d, device: %d", __func__,
                        t->d.id, t->d.size, t->d.offset, t->d.device & 0x7FFFFFFF);
+                if ((sizeof(struct dts_eagle_param_desc_alsa) + size) > 512) {
+                    ALOGE("%s: requested data too large, just return", __func__);
+                    return -1;
+                }
                 ret = do_DTS_Eagle_params(adev, t, true);
                 if (ret >= 0) {
-                    data = (int*)((char*)t + sizeof(struct dts_eagle_param_desc_alsa));
+                    data = (int*)(params + sizeof(struct dts_eagle_param_desc_alsa));
                     for (i = 0; i < count; i++)
                         idx += snprintf(&buf[idx], chars_4_int, "%i,", data[i]);
                     buf[idx > 0 ? idx-1 : 0] = 0;
                     ALOGD("DTS_EAGLE_HAL (%s): get result: %s", __func__, buf);
+                    str_parms_add_int(reply, "size", size);
                     str_parms_add_str(reply, AUDIO_PARAMETER_KEY_DTS_EAGLE, buf);
+                    str_parms_add_int(reply, "count", count);
+                    snprintf(value, sizeof(value), "0x%x", id);
+                    str_parms_add_str(reply, "id", value);
+                    str_parms_add_int(reply, "device", dev);
+                    str_parms_add_int(reply, "offset", offset);
+                    ALOGV("DTS_EAGLE_HAL (%s): reply: %s", __func__, str_parms_to_str(reply));
                 } else {
                     ALOGE("DTS_EAGLE_HAL (%s): failed getting params from kernel with error %i", __func__, ret);
+                    return -1;
                 }
-                free(t);
             } else {
                 ALOGE("DTS_EAGLE_HAL (%s): mem alloc for (get) dsp structure failed.", __func__);
+                return -1;
             }
         } else {
             ALOGE("DTS_EAGLE_HAL (%s): param (get) detected but failed parse: %s", __func__, str_parms_to_str(query));
+            return -1;
         }
     }
 
@@ -321,7 +336,7 @@ int audio_extn_dts_eagle_get_parameters(const struct audio_device *adev,
     return 0;
 }
 
-void audio_extn_dts_create_state_notifier_node(int streamOut)
+void audio_extn_dts_create_state_notifier_node(int stream_out)
 {
     char prop[PROPERTY_VALUE_MAX];
     char path[PATH_MAX];
@@ -329,9 +344,9 @@ void audio_extn_dts_create_state_notifier_node(int streamOut)
     int fd;
     property_get("use.dts_eagle", prop, "0");
     if ((!strncmp("true", prop, sizeof("true")) || atoi(prop))) {
-        ALOGV("DTS_EAGLE_NODE_STREAM (%s): create_state_notifier_node - streamOut: %d", __func__, streamOut);
+        ALOGV("DTS_EAGLE_NODE_STREAM (%s): create_state_notifier_node - stream_out: %d", __func__, stream_out);
         strlcpy(path, STATE_NOTIFY_FILE, sizeof(path));
-        snprintf(value, sizeof(value), "%d", streamOut);
+        snprintf(value, sizeof(value), "%d", stream_out);
         strlcat(path, value, sizeof(path));
 
         if ((fd=open(path, O_RDONLY)) < 0) {
@@ -351,8 +366,8 @@ void audio_extn_dts_create_state_notifier_node(int streamOut)
     }
 }
 
-void audio_extn_dts_notify_playback_state(int streamOut, int hasVideo, int sampleRate,
-                           int channels, int isPlaying, int isHpxPreprocessed) {
+void audio_extn_dts_notify_playback_state(int stream_out, int has_video, int sample_rate,
+                           int channels, int is_playing, int is_hpx_preprocessed) {
     char prop[PROPERTY_VALUE_MAX];
     char path[PATH_MAX];
     char value[MAX_LENGTH_OF_INTEGER_IN_STRING];
@@ -360,15 +375,15 @@ void audio_extn_dts_notify_playback_state(int streamOut, int hasVideo, int sampl
     int fd;
     property_get("use.dts_eagle", prop, "0");
     if ((!strncmp("true", prop, sizeof("true")) || atoi(prop))) {
-        ALOGV("DTS_EAGLE_NODE_STREAM (%s): notify_playback_state - isPlaying: %d", __func__, isPlaying);
+        ALOGV("DTS_EAGLE_NODE_STREAM (%s): notify_playback_state - is_playing: %d", __func__, is_playing);
         strlcpy(path, STATE_NOTIFY_FILE, sizeof(path));
-        snprintf(value, sizeof(value), "%d", streamOut);
+        snprintf(value, sizeof(value), "%d", stream_out);
         strlcat(path, value, sizeof(path));
         if ((fd=open(path, O_TRUNC|O_WRONLY)) < 0) {
             ALOGE("DTS_EAGLE_NODE_STREAM (%s): open state notifier node failed", __func__);
         } else {
             snprintf(buf, sizeof(buf), "has_video=%d;sample_rate=%d;channel_mode=%d;playback_state=%d;hpx_processed=%d",
-                     hasVideo, sampleRate, channels, isPlaying, isHpxPreprocessed);
+                     has_video, sample_rate, channels, is_playing, is_hpx_preprocessed);
             int n = write(fd, buf, strlen(buf));
             if (n > 0)
                 ALOGV("DTS_EAGLE_NODE_STREAM (%s): write to state notifier node successful, bytes written: %d", __func__, n);
@@ -379,17 +394,17 @@ void audio_extn_dts_notify_playback_state(int streamOut, int hasVideo, int sampl
     }
 }
 
-void audio_extn_dts_remove_state_notifier_node(int streamOut)
+void audio_extn_dts_remove_state_notifier_node(int stream_out)
 {
     char prop[PROPERTY_VALUE_MAX];
     char path[PATH_MAX];
     char value[MAX_LENGTH_OF_INTEGER_IN_STRING];
     int fd;
     property_get("use.dts_eagle", prop, "0");
-    if ((!strncmp("true", prop, sizeof("true")) || atoi(prop)) && (streamOut)) {
-        ALOGV("DTS_EAGLE_NODE_STREAM (%s): remove_state_notifier_node: streamOut - %d", __func__, streamOut);
+    if ((!strncmp("true", prop, sizeof("true")) || atoi(prop)) && (stream_out)) {
+        ALOGV("DTS_EAGLE_NODE_STREAM (%s): remove_state_notifier_node: stream_out - %d", __func__, stream_out);
         strlcpy(path, STATE_NOTIFY_FILE, sizeof(path));
-        snprintf(value, sizeof(value), "%d", streamOut);
+        snprintf(value, sizeof(value), "%d", stream_out);
         strlcat(path, value, sizeof(path));
         if ((fd=open(path, O_RDONLY)) < 0) {
             ALOGV("DTS_EAGLE_NODE_STREAM (%s): open state notifier node failed", __func__);
diff --git a/hal/audio_hw.c b/hal/audio_hw.c
index dada4d1..51b323a 100644
--- a/hal/audio_hw.c
+++ b/hal/audio_hw.c
@@ -1207,8 +1207,8 @@ int start_output_stream(struct stream_out *out)
 
         audio_extn_dts_create_state_notifier_node(out->usecase);
         audio_extn_dts_notify_playback_state(out->usecase, out->has_video, out->sample_rate,
-                                             popcount(out->channel_mask), out->playback_started,
-                                             out->is_hpx_preprocessed);
+                                             popcount(out->channel_mask),
+                                             out->playback_started, out->is_hpx_preprocessed);
 
 #ifdef DS1_DOLBY_DDP_ENABLED
         if (audio_extn_is_dolby_format(out->format))
@@ -1428,8 +1428,8 @@ static int parse_compress_metadata(struct stream_out *out, struct str_parms *par
         if (ret < 0) {
             out->is_hpx_preprocessed = (2 + ret);
             audio_extn_dts_notify_playback_state(out->usecase, out->has_video, out->sample_rate,
-                                                 popcount(out->channel_mask), out->playback_started,
-                                                 out->is_hpx_preprocessed);
+                                                 popcount(out->channel_mask), 
+                                                 out->playback_started, out->is_hpx_preprocessed);
         }
         ALOGD("%s: hpx preprocessed set to: %d", __func__, out->is_hpx_preprocessed);
     }
@@ -1537,8 +1537,8 @@ static int out_set_parameters(struct audio_stream *stream, const char *kvpairs)
         if (out->flags & AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD) {
             audio_extn_dts_create_state_notifier_node(out->usecase);
             audio_extn_dts_notify_playback_state(out->usecase, out->has_video, out->sample_rate,
-                                                 popcount(out->channel_mask), out->playback_started,
-                                                 out->is_hpx_preprocessed);
+                                                 popcount(out->channel_mask),
+                                                 out->playback_started, out->is_hpx_preprocessed);
         }
 
         pthread_mutex_unlock(&out->lock);
@@ -1682,8 +1682,8 @@ static ssize_t out_write(struct audio_stream_out *stream, const void *buffer,
 
             if (out->flags & AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD)
                 audio_extn_dts_notify_playback_state(out->usecase, out->has_video, out->sample_rate,
-                                                     popcount(out->channel_mask), out->playback_started,
-                                                     out->is_hpx_preprocessed);
+                                                     popcount(out->channel_mask),
+                                                     out->playback_started, out->is_hpx_preprocessed);
 
         }
         pthread_mutex_unlock(&out->lock);
@@ -1822,8 +1822,9 @@ static int out_pause(struct audio_stream_out* stream)
             if (!strncmp("true", prop, sizeof("true")))
                 audio_extn_dts_eagle_fade(adev, false);
             if (out->flags & AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD)
-                audio_extn_dts_notify_playback_state(out->usecase, out->has_video, out->sample_rate,
-                                                     popcount(out->channel_mask), 0, out->is_hpx_preprocessed);
+                audio_extn_dts_notify_playback_state(out->usecase, out->has_video,
+                                                     out->sample_rate, popcount(out->channel_mask),
+                                                     0, out->is_hpx_preprocessed);
         }
         pthread_mutex_unlock(&out->lock);
     }
